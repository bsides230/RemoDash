<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        :root {
            --bg-core: #050505;
            --bg-panel: #0a0a0a;
            --text-dim: #666666;
            --border-color: #222222;
            --brand-purple: #7c5cff;
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: var(--bg-core); font-family: sans-serif; }

        #tabs-bar {
            height: 32px; background: var(--bg-panel); border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; padding-left: 5px; user-select: none;
        }

        .tab {
            padding: 0 10px; height: 100%; display: flex; align-items: center; gap: 8px;
            font-size: 11px; color: var(--text-dim); cursor: pointer; border-right: 1px solid var(--border-color);
            background: var(--bg-panel); min-width: 100px; max-width: 200px;
        }
        .tab:hover { background: #111; color: #ccc; }
        .tab.active { background: var(--bg-core); color: #fff; border-bottom: 2px solid var(--brand-purple); }

        .tab-close {
            width: 14px; height: 14px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 10px; opacity: 0.5;
        }
        .tab-close:hover { background: #cc3333; color: white; opacity: 1; }

        .tab-popout { width: 14px; height: 14px; display: flex; align-items: center; justify-content: center; font-size: 10px; opacity: 0.5; margin-right: 2px; }
        .tab-popout:hover { color: var(--brand-purple); opacity: 1; }

        .new-tab-btn {
            width: 30px; height: 100%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: var(--text-dim); font-size: 16px;
        }
        .new-tab-btn:hover { color: #fff; background: #111; }

        #terminals-container {
            position: absolute; top: 32px; bottom: 0; left: 0; right: 0;
        }

        .term-wrapper {
            width: 100%; height: 100%; display: none;
        }
        .term-wrapper.active { display: block; }

        /* Scrollbar adjustment for xterm */
        .xterm-viewport::-webkit-scrollbar { width: 8px; }
        .xterm-viewport::-webkit-scrollbar-thumb { background: #333; }
    </style>
</head>
<body>

    <div id="tabs-bar">
        <div class="new-tab-btn" onclick="requestNewSession()">+</div>
    </div>

    <div id="terminals-container"></div>

    <!-- Load xterm.js -->
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

    <script>
        let coreUrl = localStorage.getItem('lyrn_core_url');
        let authToken = localStorage.getItem('lyrn_admin_token');

        let tabs = [];
        let activeTabId = null;
        let tabCounter = 0;
        let currentTheme = 'dark';
        let eventSocket = null;

        window.addEventListener('message', (e) => {
            if (e.data.type === 'CORE_URL_CHANGE') {
                coreUrl = e.data.url;
            }
            if (e.data.type === 'TOKEN_UPDATE') {
                authToken = e.data.token;
            }
            if (e.data.type === 'CHILD_RETURNING') {
                // No-op for now in persistent mode, or maybe refresh list
            }
            if (e.data.type === 'THEME_CHANGE') {
                currentTheme = e.data.theme;
                document.body.setAttribute('data-theme', e.data.theme);
                updateAllTerminalsTheme();
            }
            if (e.data.type === 'ADD_TAB') {
                // External request to add tab (e.g. from Shortcut)
                requestNewSession(e.data.cwd, e.data.command);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
             init();
        });

        async function init() {
            // Need a slight delay to ensure authToken might be populated if this is iframe
            // But usually localStorage is ready.
            if (!coreUrl) return;

            await connectEventStream();
            await loadExistingSessions();
        }

        async function loadExistingSessions() {
            if (!coreUrl || !authToken) return;
            try {
                const res = await fetch(coreUrl + '/api/terminals', {
                    headers: { 'X-Token': authToken }
                });
                if (res.ok) {
                    const sessions = await res.json();
                    // Sort by creation time?
                    sessions.sort((a,b) => a.created - b.created);

                    sessions.forEach(s => {
                        createTabUI(s.id);
                    });

                    if (sessions.length === 0) {
                        requestNewSession();
                    } else {
                        // Switch to first if none active
                        if (!activeTabId && tabs.length > 0) switchTab(tabs[0].id);
                    }
                }
            } catch(e) { console.error(e); }
        }

        async function getSessionKey() {
            if (!coreUrl || !authToken || authToken === 'NO_AUTH') return null;
            try {
                const res = await fetch(coreUrl + '/api/session/terminal', {
                    method: 'POST',
                    headers: { 'X-Token': authToken }
                });
                if(res.ok) {
                    const data = await res.json();
                    return data.key;
                }
            } catch(e) { console.error("Session key fetch failed", e); }
            return null;
        }

        async function connectEventStream() {
             if (!coreUrl) return;
             if (eventSocket) return;

             let wsUrl = coreUrl.replace('http', 'ws');
             if(wsUrl.endsWith('/')) wsUrl = wsUrl.slice(0, -1);
             wsUrl += '/api/terminal/events';

             let key = await getSessionKey();
             let query = [];
             if(key) query.push(`key=${encodeURIComponent(key)}`);
             else if(authToken) query.push(`token=${encodeURIComponent(authToken)}`);

             if(query.length > 0) wsUrl += `?${query.join('&')}`;

             eventSocket = new WebSocket(wsUrl);
             eventSocket.onmessage = (e) => {
                 try {
                     const msg = JSON.parse(e.data);
                     if (msg.type === 'create') {
                         createTabUI(msg.data.id);
                     } else if (msg.type === 'kill') {
                         removeTabUI(msg.data.id);
                     } else if (msg.type === 'init') {
                         // Initial list from socket (optional usage)
                     }
                 } catch(err) {}
             };
             eventSocket.onclose = () => {
                 eventSocket = null;
                 setTimeout(connectEventStream, 3000);
             };
        }

        async function requestNewSession(cwd=null, command=null) {
            try {
                await fetch(coreUrl + '/api/terminals', {
                    method: 'POST',
                    headers: { 'X-Token': authToken, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ cwd: cwd, command: command })
                });
            } catch(e) { console.error(e); }
        }

        function createTabUI(sessionId) {
            // Check existence
            if (tabs.find(t => t.id === sessionId)) return;

            tabCounter++; // Just for label

            // Create DOM
            const tabEl = document.createElement('div');
            tabEl.className = 'tab';
            tabEl.id = 'tab_' + sessionId;
            tabEl.innerHTML = `
                <span>Terminal ${sessionId.substr(0,4)}</span>
                <div class="tab-popout" title="Pop Out" onclick="popOutTab('${sessionId}', event)">⇱</div>
                <div class="tab-close" onclick="requestCloseTab('${sessionId}', event)">✕</div>
            `;
            tabEl.onclick = () => switchTab(sessionId);

            // Insert before the new button
            const bar = document.getElementById('tabs-bar');
            bar.insertBefore(tabEl, bar.lastElementChild);

            const container = document.getElementById('terminals-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'term-wrapper';
            wrapper.id = 'wrap_' + sessionId;
            container.appendChild(wrapper);

            // Init XTerm
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 13,
                fontFamily: '"JetBrains Mono", monospace',
                theme: getTermTheme()
            });
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(wrapper);
            fitAddon.fit();

            // Connect WS
            const termObj = {
                id: sessionId,
                term: term,
                fitAddon: fitAddon,
                socket: null,
                connected: false
            };
            tabs.push(termObj);

            connectTerminal(termObj);

            // Handle resizing
            new ResizeObserver(() => {
                if(wrapper.classList.contains('active')) {
                     fitAddon.fit();
                     if(termObj.socket && termObj.connected) {
                         termObj.socket.send(JSON.stringify({
                             type: 'resize',
                             cols: term.cols,
                             rows: term.rows
                         }));
                     }
                }
            }).observe(wrapper);

            // If no active tab, switch to this one
            if (!activeTabId) switchTab(sessionId);
        }

        async function connectTerminal(termObj) {
            let wsUrl = coreUrl.replace('http', 'ws');
            if(wsUrl.endsWith('/')) wsUrl = wsUrl.slice(0, -1);
            wsUrl += `/api/terminal/${termObj.id}`; // Connect to specific ID

            let key = await getSessionKey();
            let query = [];
            if(key) query.push(`key=${encodeURIComponent(key)}`);
            else if(authToken) query.push(`token=${encodeURIComponent(authToken)}`);

            if(query.length > 0) wsUrl += `?${query.join('&')}`;

            const socket = new WebSocket(wsUrl);
            termObj.socket = socket;

            socket.onopen = () => {
                termObj.connected = true;
                termObj.fitAddon.fit();
                // Send initial resize
                socket.send(JSON.stringify({
                    type: 'resize',
                    cols: termObj.term.cols,
                    rows: termObj.term.rows
                }));
            };

            socket.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if(msg.type === 'output') {
                        termObj.term.write(msg.data);
                    }
                } catch(e) {}
            };

            socket.onclose = (e) => {
                termObj.connected = false;
                if (e.code === 4004) {
                    // Session not found, remove it
                    removeTabUI(termObj.id);
                } else {
                    termObj.term.write("\r\n\x1b[31mDisconnected. Reconnecting...\x1b[0m\r\n");
                    setTimeout(() => connectTerminal(termObj), 3000);
                }
            };

            socket.onerror = () => {
                // socket.onclose will handle retry
            };

            termObj.term.onData(data => {
                if(termObj.connected) {
                    socket.send(JSON.stringify({ type: 'input', data: data }));
                }
            });

            termObj.term.onResize(size => {
                if(termObj.connected) {
                    socket.send(JSON.stringify({
                        type: 'resize',
                        cols: size.cols,
                        rows: size.rows
                    }));
                }
            });
        }

        function switchTab(tabId) {
            activeTabId = tabId;

            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const tabEl = document.getElementById('tab_' + tabId);
            if(tabEl) tabEl.classList.add('active');

            document.querySelectorAll('.term-wrapper').forEach(w => w.classList.remove('active'));
            const wrapEl = document.getElementById('wrap_' + tabId);
            if(wrapEl) wrapEl.classList.add('active');

            const t = tabs.find(x => x.id === tabId);
            if(t) {
                t.term.focus();
                setTimeout(() => t.fitAddon.fit(), 50);
            }
        }

        async function requestCloseTab(tabId, e) {
            if(e) e.stopPropagation();
            try {
                await fetch(coreUrl + `/api/terminals/${tabId}`, {
                    method: 'DELETE',
                    headers: { 'X-Token': authToken }
                });
            } catch(e) {}
            // Event stream will trigger removeTabUI
        }

        function removeTabUI(tabId) {
            const idx = tabs.findIndex(x => x.id === tabId);
            if(idx === -1) return;

            const t = tabs[idx];
            // Prevent reconnection loops
            if(t.socket) {
                t.socket.onclose = null;
                t.socket.close();
            }
            t.term.dispose();

            const tabEl = document.getElementById('tab_' + tabId);
            if(tabEl) tabEl.remove();

            const wrapEl = document.getElementById('wrap_' + tabId);
            if(wrapEl) wrapEl.remove();

            tabs.splice(idx, 1);

            if(activeTabId === tabId) {
                activeTabId = null;
                if(tabs.length > 0) {
                    switchTab(tabs[tabs.length - 1].id);
                }
            }
        }

        function popOutTab(tabId, e) {
            if(e) e.stopPropagation();
            // In persistent mode, we don't need to pass state. Just open window and it connects to same session.
            window.parent.postMessage({
                type: 'OPEN_CHILD_WINDOW',
                parentId: 'mod_terminal',
                id: 'term_pop_' + tabId, // Use consistent ID?
                title: 'Terminal ' + tabId.substr(0,4),
                url: 'Terminal.html?session=' + tabId, // Maybe pass param to auto-focus?
                canMinimize: true
            }, '*');

            // Should we close this tab?
            // "pop out" usually implies moving it.
            // If we close it here, we kill the view here.
            // But session remains alive.
            // Yes, let's close the UI tab here.

            // Wait, if we close the UI tab here, we are just removing the view. The session is persistent.
            // But if we use "requestCloseTab", it kills the session!
            // We must use "removeTabUI" to just close the local view.
            removeTabUI(tabId);
        }

        function getTermTheme() {
            if(currentTheme === 'light') {
                return {
                    background: '#eef0f4',
                    foreground: '#333333',
                    cursor: '#333333',
                    selection: 'rgba(0,0,0,0.1)'
                };
            } else {
                return {
                    background: '#050505',
                    foreground: '#cccccc',
                    cursor: '#ffffff',
                    selection: 'rgba(255,255,255,0.1)'
                };
            }
        }

        function updateAllTerminalsTheme() {
            const th = getTermTheme();
            tabs.forEach(t => {
                t.term.options.theme = th;
            });
        }

        window.addEventListener('resize', () => {
            if(activeTabId) {
                const t = tabs.find(x => x.id === activeTabId);
                if(t) t.fitAddon.fit();
            }
        });

    </script>
</body>
</html>